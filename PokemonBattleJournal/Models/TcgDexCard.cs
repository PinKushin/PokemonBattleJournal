// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using PokemonBattleJournal.Models;
//
//    var tcgDexCard = TcgDexCard.FromJson(jsonString);
using System;
using System.Collections.Generic;

using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace PokemonBattleJournal.Models
{
    

    public partial class TcgDexCard
    {
        [JsonProperty("category")]
        public Category Category { get; set; }

        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("illustrator", NullValueHandling = NullValueHandling.Ignore)]
        public string Illustrator { get; set; }

        [JsonProperty("image")]
        public Uri Image { get; set; }

        [JsonProperty("localId")]
        public string LocalId { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("rarity")]
        public string Rarity { get; set; }

        [JsonProperty("set")]
        public Set Set { get; set; }

        [JsonProperty("variants")]
        public Variants Variants { get; set; }

        [JsonProperty("dexId", NullValueHandling = NullValueHandling.Ignore)]
        public List<long> DexId { get; set; }

        [JsonProperty("hp", NullValueHandling = NullValueHandling.Ignore)]
        public long? Hp { get; set; }

        [JsonProperty("types", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Types { get; set; }

        [JsonProperty("evolveFrom", NullValueHandling = NullValueHandling.Ignore)]
        public string EvolveFrom { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("stage", NullValueHandling = NullValueHandling.Ignore)]
        public string Stage { get; set; }

        [JsonProperty("attacks", NullValueHandling = NullValueHandling.Ignore)]
        public List<Attack> Attacks { get; set; }

        [JsonProperty("weaknesses", NullValueHandling = NullValueHandling.Ignore)]
        public List<Weakness> Weaknesses { get; set; }

        [JsonProperty("retreat", NullValueHandling = NullValueHandling.Ignore)]
        public long? Retreat { get; set; }

        [JsonProperty("regulationMark", NullValueHandling = NullValueHandling.Ignore)]
        public string RegulationMark { get; set; }

        [JsonProperty("legal")]
        public Legal Legal { get; set; }

        [JsonProperty("updated")]
        public DateTimeOffset Updated { get; set; }

        [JsonProperty("effect", NullValueHandling = NullValueHandling.Ignore)]
        public string Effect { get; set; }

        [JsonProperty("trainerType", NullValueHandling = NullValueHandling.Ignore)]
        public string TrainerType { get; set; }

        [JsonProperty("energyType", NullValueHandling = NullValueHandling.Ignore)]
        public string EnergyType { get; set; }

        [JsonProperty("suffix", NullValueHandling = NullValueHandling.Ignore)]
        public string Suffix { get; set; }

        [JsonProperty("abilities", NullValueHandling = NullValueHandling.Ignore)]
        public List<Ability> Abilities { get; set; }
    }

    public partial class Ability
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("effect")]
        public string Effect { get; set; }
    }

    public partial class Attack
    {
        [JsonProperty("cost")]
        public List<string> Cost { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("effect", NullValueHandling = NullValueHandling.Ignore)]
        public string Effect { get; set; }

        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public Damage? Damage { get; set; }
    }

    public partial class Legal
    {
        [JsonProperty("standard")]
        public bool Standard { get; set; }

        [JsonProperty("expanded")]
        public bool Expanded { get; set; }
    }

    public partial class Set
    {
        [JsonProperty("cardCount")]
        public CardCount CardCount { get; set; }

        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("logo", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Logo { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("symbol", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Symbol { get; set; }
    }

    public partial class CardCount
    {
        [JsonProperty("official")]
        public long Official { get; set; }

        [JsonProperty("total")]
        public long Total { get; set; }
    }

    public partial class Variants
    {
        [JsonProperty("firstEdition")]
        public bool FirstEdition { get; set; }

        [JsonProperty("holo")]
        public bool Holo { get; set; }

        [JsonProperty("normal")]
        public bool Normal { get; set; }

        [JsonProperty("reverse")]
        public bool Reverse { get; set; }

        [JsonProperty("wPromo")]
        public bool WPromo { get; set; }
    }

    public partial class Weakness
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public enum Category { Energy, Pokemon, Trainer };

    public partial struct Damage
    {
        public long? Integer;
        public string String;

        public static implicit operator Damage(long Integer) => new Damage { Integer = Integer };
        public static implicit operator Damage(string String) => new Damage { String = String };
    }

    public partial class TcgDexCard
    {
        public static TcgDexCard FromJson(string json) => JsonConvert.DeserializeObject<TcgDexCard>(json, PokemonBattleJournal.Models.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this TcgDexCard self) => JsonConvert.SerializeObject(self, PokemonBattleJournal.Models.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DamageConverter.Singleton,
                CategoryConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DamageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Damage) || t == typeof(Damage?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Damage { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Damage { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Damage");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Damage)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Damage");
        }

        public static readonly DamageConverter Singleton = new DamageConverter();
    }

    internal class CategoryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Category) || t == typeof(Category?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Energy":
                    return Category.Energy;
                case "Pokemon":
                    return Category.Pokemon;
                case "Trainer":
                    return Category.Trainer;
            }
            throw new Exception("Cannot unmarshal type Category");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Category)untypedValue;
            switch (value)
            {
                case Category.Energy:
                    serializer.Serialize(writer, "Energy");
                    return;
                case Category.Pokemon:
                    serializer.Serialize(writer, "Pokemon");
                    return;
                case Category.Trainer:
                    serializer.Serialize(writer, "Trainer");
                    return;
            }
            throw new Exception("Cannot marshal type Category");
        }

        public static readonly CategoryConverter Singleton = new CategoryConverter();
    }
}
