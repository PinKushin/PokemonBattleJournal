// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using PokemonBattleJournal.Models;
//
//    var tcgDexCard = TcgDexCard.FromJson(jsonString);
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
namespace PokemonBattleJournal.Models
{


    public partial class TcgDexCard
    {
        [JsonProperty("category")]
        public string Category { get; set; }

        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("illustrator")]
        public string Illustrator { get; set; }

        [JsonProperty("image")]
        public Uri Image { get; set; }

        [JsonProperty("localId")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long LocalId { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("rarity")]
        public string Rarity { get; set; }

        [JsonProperty("set")]
        public Set Set { get; set; }

        [JsonProperty("variants")]
        public Variants Variants { get; set; }

        [JsonProperty("dexId")]
        public List<long> DexId { get; set; }

        [JsonProperty("hp")]
        public long Hp { get; set; }

        [JsonProperty("types")]
        public List<string> Types { get; set; }

        [JsonProperty("stage")]
        public string Stage { get; set; }

        [JsonProperty("abilities", NullValueHandling = NullValueHandling.Ignore)]
        public List<Ability> Abilities { get; set; }

        [JsonProperty("attacks")]
        public List<Attack> Attacks { get; set; }

        [JsonProperty("weaknesses")]
        public List<Resistance> Weaknesses { get; set; }

        [JsonProperty("retreat")]
        public long Retreat { get; set; }

        [JsonProperty("legal")]
        public Legal Legal { get; set; }

        [JsonProperty("updated")]
        public DateTimeOffset Updated { get; set; }

        [JsonProperty("resistances", NullValueHandling = NullValueHandling.Ignore)]
        public List<Resistance> Resistances { get; set; }
    }

    public partial class Ability
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("effect")]
        public string Effect { get; set; }
    }

    public partial class Attack
    {
        [JsonProperty("cost")]
        public List<string> Cost { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("effect")]
        public string Effect { get; set; }

        [JsonProperty("damage")]
        public Damage Damage { get; set; }
    }

    public partial class Legal
    {
        [JsonProperty("standard")]
        public bool Standard { get; set; }

        [JsonProperty("expanded")]
        public bool Expanded { get; set; }
    }

    public partial class Resistance
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public partial class Set
    {
        [JsonProperty("cardCount")]
        public CardCount CardCount { get; set; }

        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("logo")]
        public Uri Logo { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("symbol")]
        public Uri Symbol { get; set; }
    }

    public partial class CardCount
    {
        [JsonProperty("official")]
        public long Official { get; set; }

        [JsonProperty("total")]
        public long Total { get; set; }
    }

    public partial class Variants
    {
        [JsonProperty("firstEdition")]
        public bool FirstEdition { get; set; }

        [JsonProperty("holo")]
        public bool Holo { get; set; }

        [JsonProperty("normal")]
        public bool Normal { get; set; }

        [JsonProperty("reverse")]
        public bool Reverse { get; set; }

        [JsonProperty("wPromo")]
        public bool WPromo { get; set; }
    }

    public partial struct Damage
    {
        public long? Integer;
        public string String;

        public static implicit operator Damage(long Integer) => new Damage { Integer = Integer };
        public static implicit operator Damage(string String) => new Damage { String = String };
    }

    public partial class TcgDexCard
    {
        public static TcgDexCard FromJson(string json) => JsonConvert.DeserializeObject<TcgDexCard>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this TcgDexCard self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DamageConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DamageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Damage) || t == typeof(Damage?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Damage { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Damage { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Damage");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Damage)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Damage");
        }

        public static readonly DamageConverter Singleton = new DamageConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }
}
